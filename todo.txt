; improved-ahlrta without prim-then-act ?!

; warehouse hierarchy - successive move restriction


 
------------------------------------
From earlier meeting

- Bruce Donald ? ?? ?
- Continuous blocks
- Logistics
- Tourism

- fuel+time varaible-mpg navigation!

- Merging / splitting

Progression-free planning, with bhaskara's hierarchy (and JIt progression?)

--------------- next ---------------

Look at state estimation
  - Stuart + Eyal or Satish
  - Hector Levesque  
  - Sheila McIlraith.
Have a setting where it's obviously more efficient to do it this way.

Totem destroyer.

Planning graph with HLAs (big state spaces)

------------------------------------

What should we shoot for for journal paper?
 - Continuous
 - AADD
....
Stuart's view of continuous.
smart bisection
cell decomposition planners are angelic.
freespace
assembly or construction?  Where you can't separate the two problems.

Email about domains.

------------------------------------
 
randomize refinement ordering ??

longer term 
 - planning graph (+ relaxed)

 - AADDs.

 - ; TODO: check for consistency? Ramifications of inconsistency?
 - Unit tests for NCStrips
 - Unit tests that make sure cache/graph are working in ALTs?


 Merging nodes - do it iff rest of plan is the same ??
  ; Generalizes right-recursive thing.
  ; Can't actually prune easily, since states will be same
  ; Without pruning, this will end up with being everywhere at once -- slow!
    ; After progressing through *just next HLA*, may collapse, and can prune!!
      ; But this is just graph ? ? 
      ; Except: can save on plan suffix comparisions (push out list?) .....
      ; Graph is still good for comparing within.  i.e. L R Nav ns Nav ?
      ; Difference is graph only compares opt with pess.  This can give sub-exp just from opt?  But have to join after each action.  Unless add take-step action.
     ; Further advantage: get graph on *fragments*, not just prefixes!

 - Extend DNF valuations to keep track of unaries?
  ( and only include things in clauses where needed?)

 - Tiebreaking?

 ; Add weighted A* or that version I saw at ICAPS?



Efficiency
  Progression cache  (only 25% for now, skip)
   ; Superseded by graph search?
   ; Let descriptions do caching, or do within top-down-forward-search?
     ; Would capture restrict too
     ; Possible issue: differing hierarchical preconditions
   ; Cache instantiated NCStrips descriptions?
   ;  (allow identityhashmap...
  
 
 - Refinement cache? (i.e., JIT grounding)?

 - Combine refinement CSPs to save on making pred-maps
 - Use keyset in smart-csp filter-pos-domains when integrated- save 10%
 
 ; TODO: can we avoid making a full pass through valuation?
   i.e., just need to check a single square for no block!!
   (combination of on-demand and ...)
    But can't determine position right now without full pass.
    Would need predicate-indexed form...
    ; Right now, we do directly test against atoms when progressing...
 
 ; TODO:  Way to combine benefits of ref-generator and CSP??
 
 ; TODO: check overhead of repeated iteration through cache.
   ; Instead, just do it on the fly... (store allowed-ancestor-set in alt.)        
     Or, use transient set (once ancestor, always ancestor)
 

; Observation - constant simplifier doesn't help too much when
 you have ref generator

; Idea: angelic iwthout sets of states, just state abstraction?!

; Merge iff right-recursive ??
  
