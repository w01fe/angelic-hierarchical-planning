;;;;;;;;;;;;;;;; Implement

; Improved Nav pessimistic description.

; Ideally, pruning condition should reduce to A* graph given
  consistency, flat strips hierarchy.
; Suppose we assume consistency.

; Inconsistency of, e.g., WW heuristic can be a real problem.

In flat-strips-land, a-star graph search corresponds to: 
 - Add and prune states only before the act.  
  - If a plan is weakly dominated by another live one, prune.
  - If a better plan is generated later, then the earlier never gets
  pruned, and we get one set of extra refinements.  OK, at most
  constant factor worse.  Could be fixed by double-check before
  refining.  Or, even better, just move check to pre-refinement? 
   - Main thing we will lose is early pruning.  

 -The other thing we miss is equivalent of "closed" set, where we can
  effectively weakly prune on non-live things too.  We could do this
  on primitive prefix-hla pairs.  (?)   Do we have the guarantee that
  any (primitive prefix, state-set, HLA suffix) pair will represent
  the optimal plan to state-set when following by HLA-suffix?    When
  we expand this plan, we do, assuming consistency.    And before the,
  it's live.  So, we're golden?    Hah, unless we're inconsistent.
  And even if not.  Because another (equally good) plan may have 
 already made pessimistic claims about later states. 


If we prune a plan strictly, it can be considered live forever !
 ; But not if we prune weakly on live plan.  

What goes wrong with primitive prefix pruning?
 - Same as usual.

Suppose we allow primitive prefixes to remain live when a plan
survives.

Idea: two plans.
Second plan takes ownership of some primitive prefix, then gets pwned
by first plan.
First plan gets refined , gets pwned by this primitive prefix.

R [-1 -1 ] Nav [-3 -3] GL [-4 -4] Nav [-6 -6] T [-7 -7] ..
D [-1 -1 ] Nav [-10 -1] GL [-11 -2] Nav [-13 -4] T [-14 -5] ..
D [-1 -1 ] R [-2 -2] Nav [-10 -2] GL [-11 -3] Nav [-13 -4] T [-14 -5] ..
D [-1 -1 ] R [-2 -2] D [-3 -3] ... pruned by first plan.
R [-1 -1 ] D [-2 -2] ... pruned by third plan.

; Not even inconsistent? Hmmm.  This could be flat A*, ignoring
  everything after nav.  ****Except**** that Nav has pessimistic descriptions.

Basic pathology: prune a descendent of A by B, prune a descendent of B
by (a descendent) of A.  This cannot happen in flat A*, since
 ; the first pruning must be on a complete state sequence.
 ; thus, refining the second plan will only produce new states, not
 covered by any descendents.  

; One simple solution: associate with each plan, a set of plans pruned
  by it.  Never prune a descendent of this plan on any ancestors of
  pruned plans.  Or something like that.

; Observation: this can only happen when we prune on the exact
  description of a non-primitive HLA.  (!)
  ; Solution: if we do this, remove ancestors from allowed pruning
  set. (?).  Ancestors may be shared though.
 ; Solution: can prune weakly on *anything*, unless you're refining an
  HLA with an exact description, in which case it must be live.  :)
  (assumes consistency ... if you go exact --> inexact, you may screw
  yourself.
  Getting close though.  

; Two ways to think about it.
  - When we prune based on non-primitive sequence with exact
  description, add ancestors to black-set of this sequence.
    - Problem: black-sets may grow large, replacement policy, ...?
  - When we expand an HLA with exact description,
     only prune on live stuff.  Problem: say pessimistic drops
    off on first refinement, now we're no longer exact.
   - Is safe to store with all HLAs up to this point, :was-exact flag.
    - May prevent some pruning on worse refinements ... but no worse
    than currently.
    ; How do we interpret exact?   Upper-reward-bound of pess, opt are
    =.
   ; How do we interpret live?  Are pruned plans fair game?  NO.
  




; Add consistency enforcement to ALT, or graph search is incorrect. ?

; To ALT pruning condition, add "prune weakly if primitive prefix." ?

; Fix ALT in case of overlapping plans. (check up on this also.)

; Remove hack to ALT to show prettier graphs.


; Check on A*-graph/sloppy ALT discrepancies. (tiebreak upper-reward-bound?)

Clause-based subsumption for ALTs. (will help with WW navigation ?)s

; Think about other invalidation strategies. 

  Auto-merging above and beyond what's given.  (based on same opt-sets &
set of plans to go.  Store with each node, minimal rep. of
plan-to-go??)
 - How do we find this?  In WW and NS, "Strips-top-level" is always
 fair?  sort-of  
 - Option to turn off suffixes.
 - Try for more structure sharing
   - Merge remaining plans when we merge.  (?)  
    - Full forward-minimization is now possible.  Just merge next-maps


- When we auto-merge, how do we deal with duplicate plans?
  - Even if none, may arise when we start refining ...

  ALGs should have some mode for finding suboptimal plans.
 - Is there a simple Weighted A*/AHSS-like algorithm for ALGs, and what does it look like? Specifically, it seems like extracting optimistic state sequences may be the wrong thing to do here (instead, bias things to include more pessimistic states in the sequences?).
 TODO: a way to implement extract-a-solution (or refine potentially suboptimal things...)

 If we make things look worse in early part of the graph, we have to
touch *everything* to fix it.  Partial way around this by keeping
track of "delta"?


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Minor


- Going backwards, keep track of the reward of the second-best path. 

 - After refining a node, instead of returning directly to the root, progress forward along the optimal state sequence.  If at any point the progressed valuation assigns the regressed state a reward corresponding to a plan at least as good as the second-best path, call backwards-pass starting at this node.

 - At the other end, cache the max-gap for the current state sequence going forward from the root.  If, during a backwards pass, you hit the cached state sequence and the current max-gap is > the cached one, stop going backwards and refine right away.


;;;;;;;;;;;;;;;; Think About

 Incremental expansion.

 How to use pessimistic descriptions in ALG

hierarchical preconditions -> bhaskara  (lots more spurious states).

- What's the relationship, if any, between optimal ALG search and
  algorithms like AO*?  

 - Enforce consistency, add assertions back to sbp - difficult for
   non-simple valuations.
   - Option is to keep hierarchical structure, re-progress ... ?


;;;;;;;;;;;;;;;; General TODO


;;;;;;;;;;;;;;;;; Progression/subsumption efficiency

 - Incremental progression/merging.  It should be possible to progress only "diffs" going forward, since usually only small changes will have been made to the valuations.  This will probably be very important if the valuations get very large.  Similar indexing may allow more efficiently finding the best precursor (for OR-nodes) and the best regressed state (for AND-nodes).

Incremental progression v.2. (only progress best clauses first...) -- could
allow more merging without degenerating to symbolic BFS.

Clauses record provenance.  Assume optimsitic consistency.  rewards
always go down.  Can only affect some subest of progressed results.
By decreasing reward by x for decreased by x, or by anything for
killed state.

(If doing fancy valuation tricks, much watch out for
identitydescrpition, conditional, ...)

Might as well store provenance too, for regression ...
... and implement incremental progression/merging?
 -- But problem with provenance is things may be OK even if 
    valuation is out of date, in which case chain is invalid
    ... . . . . ...?

; Smarter way to compare vectors of rewards in subsumption ...


Better to regress partial clauses ...




---------------------------------------------------------


Later

Fancier PDF display ?

Ideas on probabilistic descriptions, synthesis, starting with flat
hierarchy, learning descriptions, macros, hierarchies bottom up.
Useful HLAs are ones with high success probability, low computational
complexity.   All of these things are context-sensitive, can be
imprecise, except for solid opt/pess descriptions.  

TODO: figure out what to do with forall conditions in NCSTRIPS.

