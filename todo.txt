TODO: Primitive should pass precondition to NCSTRIPS


Need: numeric
 - hierarchy
 - valuations
 - descriptions

- Question: all intervals, or leave in constraints?   Correlations
  would be quite nice.

- Main difference in hierarchy: numeric params can be intervals 
  ( also for primitives in these hierarchies.)

- Issue with split points:
  - Numeric fn vals become intervals
  - Split points become intervals
  - Numeric fn vals become intervals on expressions
  - ........
  - (or, regions become polytopes, set of constraints, rather than set
     of intervals. )
   - With ordinary bisection, ... 
      - this does not really come up except with pessimistic descriptions?
  
; Think: progress situation where block A, width 2, has center [1,
  3] on B of width 4.  Put down C (width 1) on block B.  

Split DNf into two clauses:

Both: A on B, C on B.
1: A left of C:    A in [1,2], C in [A+1.5, 3.5]
2. A right of C: A in [2, 3], C in [A-1.5, 3.5]

Or, if you like, A in [1,2], C in [2.5, 3.5], A + 1.5 < C.

Now, put down D (with .5) on block B .......
Still get set of binary inequalities, in fact, always
of form 0 <= A - 1 <= C - 2.5 <= d - 3.25 <= .5 

These can always be checked for feasibility in constant time.

Moreover, reward can be sum of expressions ...
  but must refer to block positions at particular points in time.
  i.e., must maintain constraints as well.

Final output of plan will essentially be set of LPs ? (equivalent to
ILP, more or less -- better or worse?).  

(for single plan, entire problem is not ILP -- PSPACE...)


Hmmm.

This may even happen when split points are not intervals? ?? 
Then, things may be even harder (assuming split points capture all
discrete behavior.).

Lets say we try to do with pure split points. 

A on B, center in [1, 3].
Put down C on B, width 1.  
Initial interval: [.5, 3.5].  Get optimistic cost, no pessimistic?
Split to [.5 2], [2 3.5].  Get Optimistic, pessimistic must deal with
overlap.  Can store constraint C + 1.5 < B, OR choose arbitrary split:
C in [.5, 1], B in [1.3] (i.e.).  Ideally, would depend on future?

Reward here must be a single number.  (?).  Or, we're back in ILP land
(?).

Split points can stay intervals.  

Simplest version: 
  No split points.  Only intervals.  Etc.  Do this first.

Even better: do everything in terms of abstract "polytope" objects.
Operations:
 - Intersect
 - Union (maybe -- won't preserve convexity)
 - ??? (operations that provide inner and outer bound, given prec +
 eff.  



; Can probably identify feasibility by repeated projection in roughly
  linear time.  OR, never, if feasible region is a single
  point... leave this to the experts.

If nonlinear, all of this goes out the window? 


Why ??




; TODO: check on testing feasibility of linear program 
  - same as solving system of equations in constraints-vars unknowns?  n^2.5-3?

; TODO: think about complextiy of hybrid-blocks. 
  - Hypothesis:
    - LP (poly) iff all fully feasible intervals for putdown specified
          ; (X left of Y)  n^4.5.
    - NP complete otherwise (rational block sizes).

deal with 0-cost actions ???  Seems not a problem in current domains/hierarchies.

; prune inconsistent intervals...

; TODO: specify split points / strategies in hierarchy!!!
; Explicitly mark interval params?

;TODO: intelligently figure out split points in terms of preconditions
 of future actions!!!!!  ! !! !!!


------------------------------------
From earlier meeting

- Bruce Donald ? ?? ?
- Continuous blocks
- Logistics
- Tourism

- fuel+time varaible-mpg navigation!

- Merging / splitting

Progression-free planning, with bhaskara's hierarchy (and JIt progression?)

--------------- next ---------------

Look at state estimation
  - Stuart + Eyal or Satish
  - Hector Levesque  
  - Sheila McIlraith.
Have a setting where it's obviously more efficient to do it this way.

Totem destroyer.

Planning graph with HLAs (big state spaces)

------------------------------------

What should we shoot for for journal paper?
 - Continuous
 - AADD
....
Stuart's view of continuous.
smart bisection
cell decomposition planners are angelic.
freespace
assembly or construction?  Where you can't separate the two problems.

Email about domains.

------------------------------------
 
randomize refinement ordering ??

longer term 
 - planning graph (+ relaxed)

 - AADDs.

 - ; TODO: check for consistency? Ramifications of inconsistency?
 - Unit tests for NCStrips
 - Unit tests that make sure cache/graph are working in ALTs?


 Merging nodes - do it iff rest of plan is the same ??
  ; Generalizes right-recursive thing.
  ; Can't actually prune easily, since states will be same
  ; Without pruning, this will end up with being everywhere at once -- slow!
    ; After progressing through *just next HLA*, may collapse, and can prune!!
      ; But this is just graph ? ? 
      ; Except: can save on plan suffix comparisions (push out list?) .....
      ; Graph is still good for comparing within.  i.e. L R Nav ns Nav ?
      ; Difference is graph only compares opt with pess.  This can give sub-exp just from opt?  But have to join after each action.  Unless add take-step action.
     ; Further advantage: get graph on *fragments*, not just prefixes!

 - Extend DNF valuations to keep track of unaries?
  ( and only include things in clauses where needed?)

 - Tiebreaking?

 ; improved-ahlrta without prim-then-act ?!

 ; Add weighted A* or that version I saw at ICAPS?



Efficiency
  Progression cache  (only 25% for now, skip)
   ; Superseded by graph search?
   ; Let descriptions do caching, or do within top-down-forward-search?
     ; Would capture restrict too
     ; Possible issue: differing hierarchical preconditions
   ; Cache instantiated NCStrips descriptions?
   ;  (allow identityhashmap...
  
 
 - Refinement cache? (i.e., JIT grounding)?

 - Combine refinement CSPs to save on making pred-maps
 - Use keyset in smart-csp filter-pos-domains when integrated- save 10%
 
 ; TODO: can we avoid making a full pass through valuation?
   i.e., just need to check a single square for no block!!
   (combination of on-demand and ...)
    But can't determine position right now without full pass.
    Would need predicate-indexed form...
    ; Right now, we do directly test against atoms when progressing...
 
 ; TODO:  Way to combine benefits of ref-generator and CSP??
 
 ; TODO: check overhead of repeated iteration through cache.
   ; Instead, just do it on the fly... (store allowed-ancestor-set in alt.)        
     Or, use transient set (once ancestor, always ancestor)
 

; Observation - constant simplifier doesn't help too much when
 you have ref generator

; Idea: angelic iwthout sets of states, just state abstraction?!

; Merge iff right-recursive ??
  
